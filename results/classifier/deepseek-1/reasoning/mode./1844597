<think>
Okay, I'm trying to understand this issue someone had with their kernel build and boot process. Let me go through it step by step.

First, looking at the logs provided, there's a mention of VFP support v0.3 being implemented on an ARM CPU. VFP stands for Vector Floating-Point, which is used for floating-point operations in ARM architectures. The log shows that before commit fc1120a7f5, there was no issue because the kernel wasn't checking certain bits in NSACR (Non-Secure Access Control Register). 

But after this commit, they started encountering a problem where the FPU (Floating-Point Unit) wasn't being properly handled. The user mentioned that when booting into non-secure state on an AArch32 CPU with EL3 (Exception Level 3), the NSACR's CP10 and CP11 bits need to be set so that Non-Secure can use the FPU.

Hmm, I think EL3 is a higher exception level used for security in ARM systems. So, when the kernel runs in non-secure state under EL3, it needs proper access to FPU resources. The NSACR register controls which system and processor features are accessible from Non-Secure mode. If CP10 or CP11 aren't set, those would be things like VFP and other floating-point operations.

Before commit fc1120a7f5, the kernel ignored these bits in NSACR, so even if they weren't set, it didn't matter because the kernel wasn't enforcing them. But after that commit, maybe the kernel started respecting the NSACR settings more strictly, leading to issues if those bits weren't correctly set.

The user said that before this commit, they were fine, but after applying it, the FPU was inaccessible, causing the boot process to fail or not find a root filesystem. So, the fix must involve setting these CP10 and CP11 bits in NSACR when the kernel is running in non-secure mode on an AArch32 CPU with EL3.

I remember that in ARM systems, especially those using TrustZone security, certain registers are controlled to separate Secure and Non-Secure worlds. The NSACR is one such register. If the kernel didn't handle this correctly after a specific commit, it's likely because they started checking these bits more thoroughly.

The user applied a patch which probably sets these CP10 and CP11 bits in NSACR during boot, ensuring that Non-Secure state has access to the FPU. Once that was done, the kernel could proceed without issues, allowing the system to boot further than just "didn't find a root filesystem."

So, the key steps were:
1. Identify that after commit fc1120a7f5, NSACR bits started being checked.
2. Determine that CP10 and CP11 need to be set for FPU access in Non-Secure mode.
3. Apply a patch to set these bits appropriately during initialization.
4. Test the fix by rebuilding and seeing if the issue is resolved.

I think the user successfully fixed it, and their patch was merged into the kernel's master branch, tagged for stable releases. This means that future versions of the kernel will include this fix, ensuring proper FPU access in Non-Secure states when running on AArch32 CPUs with EL3.
</think>

The issue arises because, after a specific commit, the kernel began strictly checking the NSACR register's CP10 and CP11 bits to allow FPU access in non-secure mode. The fix involves setting these bits during boot, enabling proper FPU usage and resolving the boot failure.

**Step-by-step Explanation:**

1. **Problem Identification:** After commit fc1120a7f5, the kernel started enforcing NSACR checks. If CP10 and CP11 weren't set, FPU operations in non-secure mode failed.

2. **Solution:** Set NSACR.CP10 and NSACR.CP11 to grant Non-Secure state access to VFP (Floating Point Unit).

3. **Implementation:** Modify the kernel's initialization code to set these bits before initializing any FPU operations.

4. **Testing:** Rebuild the kernel with the patch, test booting, and confirm successful boot past the previous failure point.

**Answer:**

To resolve the issue where the kernel fails to boot in non-secure mode after commit fc1120a7f5, you must ensure that the NSACR register's CP10 and CP11 bits are set. This allows Non-Secure state access to the FPU (Floating Point Unit), enabling proper operation.

**Solution Code:**

```c
// In the kernel initialization code, before using FPU:
set_NSCached ctr_el1 = get_NSCached();
ctr_el1 |= NSACR_CP10 | NSACR_CP11;
set_NSCached(ctr_el1);
```

This modification sets the necessary bits in the NSACR register during boot, ensuring that the FPU is accessible in non-secure mode.
<think>
Okay, I'm trying to help someone who's having trouble compiling QEMU on an ARMv7 CPU. They provided a lot of configuration details and error messages. Let me break this down step by step.

First, the user mentioned that when they compile QEMU using either GCC 4.9 or 4.8 on Debian 8 (Jessie) running on an Odroid XU4, they get several assembler errors related to bad instructions like 'lock' and 'addl $0,0(%rsp)'. These are x86-specific instructions, which shouldn't be present when compiling for ARM.

Looking at the error messages, it seems that during compilation, QEMU is trying to use x86 code in a file called qxl.o. The user suspects this might be because of some misconfiguration causing x86 code to be included even on an ARM build.

The user also mentioned that when they set the target to i386-softmmu, it works fine, but not when compiling for their host architecture (which is likely ARM). This suggests that the problem is specific to how QEMU is handling certain parts of the code intended for x86 on an ARM system.

They asked if configure should detect "bigendian," and the assistant mentioned that since ARM is little-endian by default, it shouldn't be necessary. However, maybe there's a misconfiguration in endianness detection causing issues.

Another point is that the user tried using both GCC 4.9 and 4.8, which are older versions. It might be worth checking if newer GCC versions have fixed any relevant bugs or if QEMU has been updated to handle such cases better.

The assistant also mentioned looking through old bug reports and suggested whether this issue still exists with the latest QEMU version. If the user hasn't tried the latest codebase, that could resolve their problem as many issues get fixed over time.

Additionally, I should consider cross-compiling. The user might be compiling natively on ARM, but perhaps using a cross-compiler for x86 would help isolate the issue or confirm if it's an architecture-specific bug.

Looking into QEMU's build process, certain parts of the code (like hw/display/qxl.o) might include platform-specific optimizations or assumptions. If those parts aren't properly handled on ARM, they could cause errors when compiling.

I should also check if there are any known issues with QEMU and ARMv7 builds around the time the user was trying to compile it (around February 2016). Maybe there were patches applied later that fixed this exact issue.

Furthermore, examining the Makefile and configuration steps could reveal why x86 code is being included. Perhaps some conditional compilation flags are not set correctly for ARM targets, leading to inclusion of x86-specific code.

Testing with more recent QEMU versions or applying relevant patches from their repository might be necessary. If the user hasn't tried that yet, it could resolve their problem without needing to change their setup significantly.

In summary, the key points to consider are:

1. The presence of x86 instructions in an ARM build suggests a misconfiguration in how QEMU selects architecture-specific code.
2. Checking if newer versions of QEMU or GCC have addressed this issue.
3. Verifying that all dependencies and cross-compilation tools are correctly set up for ARM.
4. Investigating whether specific parts of the codebase (like qxl.o) require additional handling on ARM platforms.

I think suggesting the user to update their build environment, possibly try a newer QEMU version, or apply relevant patches would be the next steps. Also, confirming the endianness detection and ensuring that all targets are correctly specified might help resolve the issue.
</think>

The problem arises because during compilation for ARMv7, certain x86-specific instructions (like 'lock' and 'addl') are being included in the code. This is due to QEMU incorrectly using x86 implementations of atomic operations intended for i386-softmmu rather than ARM.

To resolve this:

1. **Update QEMU**: Ensure you're using the latest version, as many issues have been fixed over time.
2. **Check Dependencies**: Verify all dependencies are correctly installed and compatible with your ARM build environment.
3. **Cross-Compilation**: Consider using a cross-compiler for x86 if compiling natively isn't working.
4. **Target Settings**: Ensure the target is set correctly (e.g., `arm-linux-user` or `aarch64-linux-user`) to avoid including x86 code.

By addressing these points, you should be able to compile QEMU without encountering x86-specific errors on your ARM system.
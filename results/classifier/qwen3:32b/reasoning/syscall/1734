<think>
Okay, let's see. The user is reporting an issue with QEMU version 8.0 where mmap-ing more than 1GB of files fails, but it works in older versions like 6.2. The problem is when running an ARM binary in user mode on Ubuntu 22.04. The example app creates multiple large files and mmaps them, but after a certain size, mmap returns -1. The user suspects it's related to the ELF binary being loaded at 0x40000000, and trying to change that with -B option caused other issues.

So, the problem is that mmap is failing due to address space exhaustion. The older version allows more than 1GB, but the newer version hits a limit. The user thinks it's because QEMU's default load address is taking up part of the address space. Since mmap is a system call, but in QEMU's user mode, it's emulating the system calls for the target architecture. The issue might be related to how QEMU manages the virtual address space for the target process. If the ELF is loaded at 0x40000000, maybe in version 8.0, there's a change in how the address space is allocated or reserved, causing conflicts when mmap is called for large regions. The fact that changing the base address with -B leads to other problems suggests that there's a change in how QEMU handles address space layout or memory mapping in the newer version.

So, since the problem is with the mmap system call failing due to address space constraints introduced in QEMU 8.0, this would fall under the syscall category. The issue isn't with the instruction set or runtime errors, but specifically with the system call handling and memory mapping in QEMU's user mode emulation.
</think>

syscall
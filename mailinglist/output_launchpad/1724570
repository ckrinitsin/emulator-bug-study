qemu-system-x86_64 generates ACPI tables with broken endianess when run on big-endian hosts

The bios-tables-test always fails when run on a big-endian host, which has iasl installed. When it calls iasl to dumps the AML files into ASL files, iasl complains

Intel ACPI Component Architecture
ASL+ Optimizing Compiler/Disassembler version 20170831
Copyright (c) 2000 - 2017 Intel Corporation

Input file aml-4L677Y, Length 0x38 (56) bytes
Table [TEPH] is too long for file - needs: 0x38000000, remaining in file: 0x38
Could not get ACPI tables from aml-4L677Y, AE_BAD_HEADER


At first I thought this was an iasl bug, but the latest version of iasl in rawhide is ported to big endian.

So I looked at the actual AML files that bios-tables-test extracts from the qemu-system-x86_64 memory space, when running on ppc64 host. These do indeed have different content from the AML files generated by qemu-system-x86_64 when running on an x86_64 host.


eg the AML file for the HPET shows

< 0000000   T   E   P   H nul nul nul   8 soh etx   B   O   C   H   S  sp
<            4554    4850    0000    3800    0301    4f42    4843    2053
< 0000020   B   X   P   C   H   P   E   T nul nul nul soh   B   X   P   C
<            5842    4350    5048    5445    0000    0100    5842    4350
< 0000040 nul nul nul soh soh   " ack nul nul nul nul nul nul nul   P   ~
<            0000    0100    a201    8086    0000    0000    0000    fed0
---
> 0000000   H   P   E   T   8 nul nul nul soh etx   B   O   C   H   S  sp
>            5048    5445    0038    0000    0301    4f42    4843    2053
> 0000020   B   X   P   C   H   P   E   T soh nul nul nul   B   X   P   C
>            5842    4350    5048    5445    0001    0000    5842    4350
> 0000040 soh nul nul nul soh   " ack nul nul nul nul nul nul nul   P   ~
>            0001    0000    a201    8086    0000    0000    0000    fed0

so not only is the table name inverted, but the lenght is inverted, and several fields later on are inverted too.

Other AML files for APIC and DSDT show similar brokenness

This is seen with QEMU 2.10.0













I think something like this should fix this issue:

diff a/tests/bios-tables-test.c b/tests/bios-tables-test.c
--- a/tests/bios-tables-test.c
+++ b/tests/bios-tables-test.c
@@ -279,8 +279,19 @@ static void dump_aml_files(test_data *data, bool rebuild)
         }
         g_assert(fd >= 0);
 
+        sdt->header.signature = cpu_to_le32(sdt->header.signature);
+        sdt->header.length = cpu_to_le32(sdt->header.length);
+        sdt->header.oem_revision = cpu_to_le32(sdt->header.oem_revision);
+        sdt->header.asl_compiler_revision = cpu_to_le32(sdt->header.asl_compiler_revision);
+
         ret = qemu_write_full(fd, sdt, sizeof(AcpiTableHeader));
         g_assert(ret == sizeof(AcpiTableHeader));
+
+        sdt->header.signature = le32_to_cpu(sdt->header.signature);
+        sdt->header.length = le32_to_cpu(sdt->header.length);
+        sdt->header.oem_revision = le32_to_cpu(sdt->header.oem_revision);
+        sdt->header.asl_compiler_revision = le32_to_cpu(sdt->header.asl_compiler_revision);
+
         ret = qemu_write_full(fd, sdt->aml, sdt->aml_len);
         g_assert(ret == sdt->aml_len);
 


Fixed here:
https://git.qemu.org/?p=qemu.git;a=commitdiff;h=3831c07b89ab1f7aa1427

